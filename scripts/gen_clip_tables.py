#!/usr/bin/env python3
"""
Generate small-N convex clip jump-table match arms.

This writes `src/knn_clipping/clip_tables/ngon_n{N}.rs` for N=3..=8.

The generated files are intended to be used via:

    match mask {
        include!("clip_tables/ngon_n4.rs");
        _ => fallback(...),
    }

and assume `push_entry!`, `push_v!`, and `push_exit!` macros exist in scope.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True)
class Case:
    mask: int
    start: int
    length: int
    prev: int
    last: int
    next_: int
    verts: tuple[int, ...]


def gen_cases(n: int) -> list[Case]:
    full_mask = (1 << n) - 1
    cases: dict[int, Case] = {}

    for start in range(n):
        for length in range(1, n):
            mask = 0
            verts: list[int] = []
            for k in range(length):
                idx = (start + k) % n
                mask |= 1 << idx
                verts.append(idx)

            if mask == 0 or mask == full_mask:
                continue

            prev = (start + n - 1) % n
            last = (start + length - 1) % n
            next_ = (last + 1) % n

            # Masks should be unique for contiguous runs, but dedup by mask defensively.
            cases.setdefault(
                mask,
                Case(
                    mask=mask,
                    start=start,
                    length=length,
                    prev=prev,
                    last=last,
                    next_=next_,
                    verts=tuple(verts),
                ),
            )

    return [cases[m] for m in sorted(cases)]

def gen_table(n: int) -> list[tuple[int, int]]:
    """
    For each mask in 0..(1<<n), return (start,len) for contiguous runs, else (0,0).

    - start: entry_next index (first inside after an outside)
    - len: popcount(mask)

    This excludes mask==0 and mask==full (returned as (0,0) and handled by the caller).
    """
    full_mask = (1 << n) - 1
    table: list[tuple[int, int]] = [(0, 0)] * (1 << n)

    for mask in range(1 << n):
        if mask == 0 or mask == full_mask:
            continue

        # Contiguous iff there are exactly 2 transitions between adjacent bits in the cyclic mask.
        prev_mask = ((mask << 1) | (mask >> (n - 1))) & full_mask
        trans_mask = (mask ^ prev_mask) & full_mask
        if trans_mask.bit_count() != 2:
            continue

        idx1 = (trans_mask & -trans_mask).bit_length() - 1
        trans_mask_rem = trans_mask & ~(1 << idx1)
        idx2 = (trans_mask_rem & -trans_mask_rem).bit_length() - 1

        # If mask[k] is 1 at a transition k, then (k-1)->k is outside->inside => entry_next = k.
        if (mask & (1 << idx1)) != 0:
            entry_next = idx1
        else:
            entry_next = idx2

        inside_count = mask.bit_count()
        table[mask] = (entry_next, inside_count)

    return table


def render_file(n: int) -> str:
    lanes = 4 if n <= 4 else 8
    lines: list[str] = []
    lines.append("// @generated by `scripts/gen_clip_tables.py`; do not edit by hand.")
    lines.append(f"// Jump-table match arms for convex clipping, N={n}.")
    lines.append(f"// Distances array lanes: {lanes}.")
    lines.append("//")
    lines.append("// Each case corresponds to a single contiguous run of inside vertices (cyclic).")
    lines.append("")

    lines.append("match mask {")
    for c in gen_cases(n):
        bits = format(c.mask, f"0{n}b")
        lines.append(f"    // start={c.start} len={c.length} mask=0b{bits}")
        body: list[str] = []
        body.append(f"ctx.push_entry::<{lanes}, {c.start}, {c.prev}, {c.prev}>(dists);")
        for v in c.verts:
            body.append(f"ctx.push_v::<{v}>();")
        body.append(f"ctx.push_exit::<{lanes}, {c.last}, {c.next_}, {c.last}>(dists);")
        joined = " ".join(body)
        lines.append(f"    0b{bits} => {{ {joined} }},")

    lines.append("    _ => return fallback(ctx.poly, ctx.hp, ctx.out),")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)

def render_table_file(n: int) -> str:
    table = gen_table(n)
    lines: list[str] = []
    lines.append("// @generated by `scripts/gen_clip_tables.py`; do not edit by hand.")
    lines.append(f"// (start,len) lookup table for contiguous inside runs, N={n}.")
    lines.append("//")
    lines.append("// Entry is (0,0) for:")
    lines.append("// - mask==0 (all outside)")
    lines.append("// - mask==full (all inside)")
    lines.append("// - non-contiguous/disconnected masks (should be impossible for convex clip)")
    lines.append("")
    lines.append(f"pub(super) const TABLE_N{n}: [(u8, u8); {1<<n}] = [")
    for i, (start, length) in enumerate(table):
        lines.append(f"    ({start}u8, {length}u8), // 0b{format(i, f'0{n}b')}")
    lines.append("];")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    out_dir = repo_root / "src" / "knn_clipping" / "clip_tables"
    out_dir.mkdir(parents=True, exist_ok=True)

    for n in range(3, 9):
        out_path = out_dir / f"ngon_n{n}.rs"
        out_path.write_text(render_file(n), encoding="utf-8")
        table_path = out_dir / f"table_n{n}.rs"
        table_path.write_text(render_table_file(n), encoding="utf-8")


if __name__ == "__main__":
    main()
