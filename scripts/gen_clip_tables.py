#!/usr/bin/env python3
"""
Generate small-N convex clip jump-table match arms.

This writes `src/knn_clipping/clip_tables/ngon_n{N}.rs` for N=3..=8.

The generated files are intended to be used via:

    match mask {
        include!("clip_tables/ngon_n4.rs");
        _ => fallback(...),
    }

and assume `push_entry!`, `push_v!`, and `push_exit!` macros exist in scope.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True)
class Case:
    mask: int
    start: int
    length: int
    prev: int
    last: int
    next_: int
    verts: tuple[int, ...]


def gen_cases(n: int) -> list[Case]:
    full_mask = (1 << n) - 1
    cases: dict[int, Case] = {}

    for start in range(n):
        for length in range(1, n):
            mask = 0
            verts: list[int] = []
            for k in range(length):
                idx = (start + k) % n
                mask |= 1 << idx
                verts.append(idx)

            if mask == 0 or mask == full_mask:
                continue

            prev = (start + n - 1) % n
            last = (start + length - 1) % n
            next_ = (last + 1) % n

            # Masks should be unique for contiguous runs, but dedup by mask defensively.
            cases.setdefault(
                mask,
                Case(
                    mask=mask,
                    start=start,
                    length=length,
                    prev=prev,
                    last=last,
                    next_=next_,
                    verts=tuple(verts),
                ),
            )

    return [cases[m] for m in sorted(cases)]


def render_file(n: int) -> str:
    lines: list[str] = []
    lines.append("// @generated by `scripts/gen_clip_tables.py`; do not edit by hand.")
    lines.append(f"// Jump-table match arms for convex clipping, N={n}.")
    lines.append("//")
    lines.append("// Each case corresponds to a single contiguous run of inside vertices (cyclic).")
    lines.append("")

    lines.append("match mask {")
    for c in gen_cases(n):
        bits = format(c.mask, f"0{n}b")
        lines.append(f"    // start={c.start} len={c.length} mask=0b{bits}")
        body: list[str] = []
        body.append(f"ctx.push_entry(dists, {c.start}, {c.prev}, {c.prev});")
        for v in c.verts:
            body.append(f"ctx.push_v({v});")
        body.append(f"ctx.push_exit(dists, {c.last}, {c.next_}, {c.last});")
        joined = " ".join(body)
        lines.append(f"    0b{bits} => {{ {joined} }},")

    lines.append("    _ => return fallback(ctx.poly, ctx.hp, ctx.out),")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    out_dir = repo_root / "src" / "knn_clipping" / "clip_tables"
    out_dir.mkdir(parents=True, exist_ok=True)

    for n in range(3, 9):
        out_path = out_dir / f"ngon_n{n}.rs"
        out_path.write_text(render_file(n), encoding="utf-8")


if __name__ == "__main__":
    main()
