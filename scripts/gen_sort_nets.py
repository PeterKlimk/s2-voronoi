#!/usr/bin/env python3
"""
Generate sorting network code for u64 values.

Generates:
- sort8_net: 8-element network using registers
- sort16_tail_out: 16-element hybrid network writing tail via out ptr
- sort24_tail_out: 24-element hybrid network writing tail via out ptr

Uses data from sorting_networks.json
"""

import argparse
import json
from pathlib import Path


def load_networks():
    """Load sorting network data from JSON."""
    json_path = Path(__file__).parent.parent / "sorting_networks.json"
    with open(json_path) as f:
        return json.load(f)


def emit_header():
    return """// Auto-generated by scripts/gen_sort_nets.py
// Do not edit manually!

use std::hint::select_unpredictable;
use std::ptr;

/// Compare-swap two registers using cmov via `select_unpredictable`.
#[inline(always)]
fn cswap_reg(a: &mut u64, b: &mut u64) {
    let va = *a;
    let vb = *b;
    let cond = va <= vb;
    *a = select_unpredictable(cond, va, vb);
    *b = select_unpredictable(cond, vb, va);
}

/// Compare-swap a register (higher index) with a pointer element (lower index).
/// After: `*base[idx] = min(val, reg)` and `*reg = max(val, reg)`.
#[inline(always)]
unsafe fn cswap_reg_ptr(reg: &mut u64, base: *mut u64, idx: usize) {
    let ptr = base.add(idx);
    let val = *ptr;
    let r = *reg;
    let cond = val <= r;
    *ptr = select_unpredictable(cond, val, r); // ptr gets min
    *reg = select_unpredictable(cond, r, val); // reg gets max
}

/// Compare-swap two pointer elements using cmov.
/// After: base[i] = min(a,b), base[j] = max(a,b) where j > i.
#[inline(always)]
unsafe fn cswap_ptr(base: *mut u64, i: usize, j: usize) {
    let pi = base.add(i);
    let pj = base.add(j);
    let a = *pi;  // at lower index i
    let b = *pj;  // at higher index j
    // Smaller should go to lower index (i)
    let cond = a <= b;
    *pi = select_unpredictable(cond, a, b);  // i gets min
    *pj = select_unpredictable(cond, b, a);  // j gets max
}

"""


def emit_sort8(networks):
    """Generate 8-element sorting network (8 registers, no slice)."""
    data = networks["8"]
    comparators = data["comparators"]
    
    lines = ["/// Sort 8 elements using a sorting network (all in registers)."]
    lines.append("/// Returns sorted array.")
    lines.append("#[inline(always)]")
    lines.append("pub fn sort8_net(")
    lines.append("    mut r0: u64, mut r1: u64, mut r2: u64, mut r3: u64,")
    lines.append("    mut r4: u64, mut r5: u64, mut r6: u64, mut r7: u64,")
    lines.append(") -> [u64; 8] {")
    
    for i, j in comparators:
        if i > j:
            i, j = j, i
        lines.append(f"    cswap_reg(&mut r{i}, &mut r{j});")
    
    lines.append("    [r0, r1, r2, r3, r4, r5, r6, r7]")
    lines.append("}")
    return "\n".join(lines)


def emit_hybrid_sort_tail_out(networks, key, fn_name, num_slice, doc_slice_len):
    """Generate a hybrid sorting network that stores the last tail_len values via out ptr."""
    data = networks[key]
    comparators = data["comparators"]

    n_total = int(key)
    assert n_total == num_slice + 8

    lines = [f"/// Sort {n_total} elements using a hybrid sorting network."]
    lines.append(
        f"/// First {doc_slice_len} elements are in the slice at `base`, remaining up to 8 are in `base[{doc_slice_len}..]`."
    )
    lines.append("///")
    lines.append(
        "/// Loads up to `tail_len` values from the tail, fills the remainder with the sentinel `u64::MAX`,"
    )
    lines.append("/// runs the sorting network, then stores only the first `tail_len` tail outputs into `out`.")
    lines.append("///")
    lines.append("/// This is optimized for the common padded case where `tail_len < 8`.")
    lines.append("///")
    lines.append("/// # Safety")
    lines.append(f"/// - `base` must point to at least {doc_slice_len} valid u64 elements")
    lines.append("/// - `out` must point to at least `tail_len` valid u64 elements")
    lines.append("/// - `tail_len <= 8`")
    lines.append("/// - Callers must ensure `u64::MAX` does not appear in the input values when using padding")
    # Keep this as an out-of-line function by default to avoid code-size bloat when
    # used as a building block (e.g., inside larger routines).
    lines.append(f"pub unsafe fn {fn_name}(base: *mut u64, out: *mut u64, tail_len: usize) {{")
    lines.append("    debug_assert!(tail_len <= 8);")
    lines.append("")
    lines.append("    // Load tail registers (pad with sentinels).")
    lines.append(f"    let tail = base.add({doc_slice_len});")
    lines.append("    let mut r0 = u64::MAX;")
    lines.append("    let mut r1 = u64::MAX;")
    lines.append("    let mut r2 = u64::MAX;")
    lines.append("    let mut r3 = u64::MAX;")
    lines.append("    let mut r4 = u64::MAX;")
    lines.append("    let mut r5 = u64::MAX;")
    lines.append("    let mut r6 = u64::MAX;")
    lines.append("    let mut r7 = u64::MAX;")
    lines.append("    if tail_len == 8 {")
    lines.append("        r0 = ptr::read(tail.add(0));")
    lines.append("        r1 = ptr::read(tail.add(1));")
    lines.append("        r2 = ptr::read(tail.add(2));")
    lines.append("        r3 = ptr::read(tail.add(3));")
    lines.append("        r4 = ptr::read(tail.add(4));")
    lines.append("        r5 = ptr::read(tail.add(5));")
    lines.append("        r6 = ptr::read(tail.add(6));")
    lines.append("        r7 = ptr::read(tail.add(7));")
    lines.append("    } else {")
    lines.append("        match tail_len {")
    lines.append("            0 => {}")
    lines.append("            1 => { r0 = ptr::read(tail.add(0)); }")
    lines.append("            2 => { r0 = ptr::read(tail.add(0)); r1 = ptr::read(tail.add(1)); }")
    lines.append("            3 => { r0 = ptr::read(tail.add(0)); r1 = ptr::read(tail.add(1)); r2 = ptr::read(tail.add(2)); }")
    lines.append("            4 => { r0 = ptr::read(tail.add(0)); r1 = ptr::read(tail.add(1)); r2 = ptr::read(tail.add(2)); r3 = ptr::read(tail.add(3)); }")
    lines.append("            5 => { r0 = ptr::read(tail.add(0)); r1 = ptr::read(tail.add(1)); r2 = ptr::read(tail.add(2)); r3 = ptr::read(tail.add(3)); r4 = ptr::read(tail.add(4)); }")
    lines.append("            6 => { r0 = ptr::read(tail.add(0)); r1 = ptr::read(tail.add(1)); r2 = ptr::read(tail.add(2)); r3 = ptr::read(tail.add(3)); r4 = ptr::read(tail.add(4)); r5 = ptr::read(tail.add(5)); }")
    lines.append("            7 => { r0 = ptr::read(tail.add(0)); r1 = ptr::read(tail.add(1)); r2 = ptr::read(tail.add(2)); r3 = ptr::read(tail.add(3)); r4 = ptr::read(tail.add(4)); r5 = ptr::read(tail.add(5)); r6 = ptr::read(tail.add(6)); }")
    lines.append("            _ => unreachable!(),")
    lines.append("        }")
    lines.append("    }")
    lines.append("")

    for i, j in comparators:
        if i > j:
            i, j = j, i

        i_is_reg = i >= num_slice
        j_is_reg = j >= num_slice

        if i_is_reg and j_is_reg:
            lines.append(f"    cswap_reg(&mut r{i - num_slice}, &mut r{j - num_slice});")
        else:
            if not j_is_reg:
                lines.append(f"    cswap_ptr(base, {i}, {j});")
            else:
                lines.append(f"    cswap_reg_ptr(&mut r{j - num_slice}, base, {i});")

    lines.append("")
    lines.append("    match tail_len {")
    lines.append("        0 => {}")
    lines.append("        1 => *out.add(0) = r0,")
    lines.append("        2 => { *out.add(0) = r0; *out.add(1) = r1; }")
    lines.append("        3 => { *out.add(0) = r0; *out.add(1) = r1; *out.add(2) = r2; }")
    lines.append(
        "        4 => { *out.add(0) = r0; *out.add(1) = r1; *out.add(2) = r2; *out.add(3) = r3; }"
    )
    lines.append(
        "        5 => { *out.add(0) = r0; *out.add(1) = r1; *out.add(2) = r2; *out.add(3) = r3; *out.add(4) = r4; }"
    )
    lines.append(
        "        6 => { *out.add(0) = r0; *out.add(1) = r1; *out.add(2) = r2; *out.add(3) = r3; *out.add(4) = r4; *out.add(5) = r5; }"
    )
    lines.append(
        "        7 => { *out.add(0) = r0; *out.add(1) = r1; *out.add(2) = r2; *out.add(3) = r3; *out.add(4) = r4; *out.add(5) = r5; *out.add(6) = r6; }"
    )
    lines.append(
        "        8 => { *out.add(0) = r0; *out.add(1) = r1; *out.add(2) = r2; *out.add(3) = r3; *out.add(4) = r4; *out.add(5) = r5; *out.add(6) = r6; *out.add(7) = r7; }"
    )
    lines.append("        _ => unreachable!(),")
    lines.append("    }")
    lines.append("}")
    return "\n".join(lines)

def emit_hybrid_sort_tail_out_var_regs(networks, key, fn_name, num_slice, num_regs, vis="pub"):
    """Like emit_hybrid_sort_tail_out, but supports a variable number of tail registers."""
    data = networks[key]
    comparators = data["comparators"]

    n_total = int(key)
    assert n_total == num_slice + num_regs
    assert 1 <= num_regs <= 8

    lines = [f"/// Sort {n_total} elements using a hybrid sorting network (tail regs = {num_regs})."]
    lines.append(
        f"/// First {num_slice} elements are in the slice at `base`, remaining up to {num_regs} are in `base[{num_slice}..]`."
    )
    lines.append("///")
    lines.append(
        f"/// Loads up to `tail_len` values from the tail, fills the remainder with the sentinel `u64::MAX`,"
    )
    lines.append("/// runs the sorting network, then stores only the first `tail_len` tail outputs into `out`.")
    lines.append("///")
    lines.append("/// This is intended for microbench experiments and is not part of the library API.")
    lines.append("///")
    lines.append("/// # Safety")
    lines.append(f"/// - `base` must point to at least {num_slice} valid u64 elements")
    lines.append("/// - `out` must point to at least `tail_len` valid u64 elements")
    lines.append(f"/// - `tail_len <= {num_regs}`")
    lines.append("/// - Callers must ensure `u64::MAX` does not appear in the input values when using padding")
    lines.append(f"{vis} unsafe fn {fn_name}(base: *mut u64, out: *mut u64, tail_len: usize) {{")
    lines.append(f"    debug_assert!(tail_len <= {num_regs});")
    lines.append("")
    lines.append("    // Load tail registers (pad with sentinels).")
    lines.append(f"    let tail = base.add({num_slice});")

    for i in range(num_regs):
        lines.append(f"    let mut r{i} = u64::MAX;")

    lines.append(f"    if tail_len == {num_regs} {{")
    for i in range(num_regs):
        lines.append(f"        r{i} = ptr::read(tail.add({i}));")
    lines.append("    } else {")
    lines.append("        match tail_len {")
    lines.append("            0 => {}")
    for tl in range(1, num_regs):
        reads = " ".join([f"r{i} = ptr::read(tail.add({i}));" for i in range(tl)])
        lines.append(f"            {tl} => {{ {reads} }}")
    lines.append(f"            {num_regs} => unreachable!(),")
    lines.append("            _ => unreachable!(),")
    lines.append("        }")
    lines.append("    }")
    lines.append("")

    # Map comparator indices into either base pointers or tail regs.
    for i, j in comparators:
        if i > j:
            i, j = j, i

        i_is_reg = i >= num_slice
        j_is_reg = j >= num_slice

        if i_is_reg and j_is_reg:
            lines.append(f"    cswap_reg(&mut r{i - num_slice}, &mut r{j - num_slice});")
        else:
            if not j_is_reg:
                lines.append(f"    cswap_ptr(base, {i}, {j});")
            else:
                lines.append(f"    cswap_reg_ptr(&mut r{j - num_slice}, base, {i});")

    lines.append("")
    lines.append("    match tail_len {")
    lines.append("        0 => {}")
    for tl in range(1, num_regs + 1):
        stores = " ".join([f"*out.add({i}) = r{i};" for i in range(tl)])
        lines.append(f"        {tl} => {{ {stores} }}")
    lines.append("        _ => unreachable!(),")
    lines.append("    }")
    lines.append("}")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--write",
        action="store_true",
        help="Write generated code to src/sort_nets.rs instead of stdout.",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Exit non-zero if src/sort_nets.rs is out of date.",
    )
    args = parser.parse_args()

    networks = load_networks()

    output = []
    output.append(emit_header())
    output.append(emit_sort8(networks))
    output.append("")
    output.append(
        emit_hybrid_sort_tail_out(
            networks,
            key="16",
            fn_name="sort16_tail_out",
            num_slice=8,
            doc_slice_len=8,
        )
    )
    output.append("")
    output.append(
        emit_hybrid_sort_tail_out(
            networks,
            key="24",
            fn_name="sort24_tail_out",
            num_slice=16,
            doc_slice_len=16,
        )
    )
    output.append("")
    output.append("// Internal tail4 variants for pad-up ranges (to reduce live regs/spills).")
    output.append(
        emit_hybrid_sort_tail_out_var_regs(
            networks,
            key="16",
            fn_name="sort16_tail_out_12_4",
            num_slice=12,
            num_regs=4,
            vis="pub(crate)",
        )
    )
    output.append("")
    output.append(
        emit_hybrid_sort_tail_out_var_regs(
            networks,
            key="24",
            fn_name="sort24_tail_out_20_4",
            num_slice=20,
            num_regs=4,
            vis="pub(crate)",
        )
    )
    output.append(emit_tests())
    rendered = "\n".join(output)

    out_path = Path(__file__).parent.parent / "src" / "sort_nets.rs"
    if args.check:
        existing = out_path.read_text()
        if existing != rendered:
            raise SystemExit(
                "src/sort_nets.rs is out of date (run scripts/gen_sort_nets.py --write)"
            )
        return

    if args.write:
        out_path.write_text(rendered)
        return

    print(rendered)


def emit_tests():
    return """

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sort8_net() {
        let result = sort8_net(5, 2, 8, 1, 9, 3, 7, 4);
        assert_eq!(result, [1, 2, 3, 4, 5, 7, 8, 9]);
    }

    #[test]
    fn test_sort8_net_sorted() {
        let result = sort8_net(1, 2, 3, 4, 5, 6, 7, 8);
        assert_eq!(result, [1, 2, 3, 4, 5, 6, 7, 8]);
    }

    #[test]
    fn test_sort8_net_reverse() {
        let result = sort8_net(8, 7, 6, 5, 4, 3, 2, 1);
        assert_eq!(result, [1, 2, 3, 4, 5, 6, 7, 8]);
    }

    #[test]
    fn test_sort16_tail_out_exact() {
        let mut v = vec![16u64, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
        unsafe { sort16_tail_out(v.as_mut_ptr(), v.as_mut_ptr().add(8), 8) };
        assert_eq!(
            v,
            vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
        );
    }

    #[test]
    fn test_sort24_tail_out_exact() {
        let mut v = vec![
            24u64, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4,
            3, 2, 1,
        ];
        unsafe { sort24_tail_out(v.as_mut_ptr(), v.as_mut_ptr().add(16), 8) };
        assert_eq!(
            v,
            vec![
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
                22, 23, 24
            ]
        );
    }
}
"""


if __name__ == "__main__":
    main()
