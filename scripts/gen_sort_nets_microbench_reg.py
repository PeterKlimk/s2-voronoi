#!/usr/bin/env python3
"""
Generate register-based sorting networks for microbenchmarks.

This emits a "load once, compare-swap in locals, store once" implementation for each N in 2..=32.
It is intended for apples-to-apples comparison against the pointer-based networks in
`src/bin_support/sort_nets_microbench.rs`.

Output:
  src/bin_support/sort_nets_microbench_reg.rs
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path


def load_networks(repo_root: Path) -> dict[int, list[tuple[int, int]]]:
    raw = json.loads((repo_root / "sorting_networks.json").read_text())
    out: dict[int, list[tuple[int, int]]] = {}
    for k, v in raw.items():
        n = int(k)
        comps = [(int(a), int(b)) for a, b in v["comparators"]]
        out[n] = comps
    return out


def emit_header() -> str:
    return "\n".join(
        [
            "// Auto-generated by scripts/gen_sort_nets_microbench_reg.py",
            "// Do not edit manually!",
            "",
            "use std::hint::select_unpredictable;",
            "use std::ptr;",
            "",
            "/// Compare-swap two registers using cmov via `select_unpredictable`.",
            "#[inline(always)]",
            "fn cswap_reg(a: &mut u64, b: &mut u64) {",
            "    let va = *a;",
            "    let vb = *b;",
            "    let cond = va <= vb;",
            "    *a = select_unpredictable(cond, va, vb);",
            "    *b = select_unpredictable(cond, vb, va);",
            "}",
        ]
    )


def emit_sort_fn(n: int, comps: list[tuple[int, int]]) -> str:
    lines: list[str] = []
    lines.append("")
    lines.append(f"/// Sorting network for N={n} (load once, store once).")
    lines.append("#[inline(always)]")
    lines.append(f"pub unsafe fn sort{n}_net(base: *mut u64) {{")
    for i in range(n):
        lines.append(f"    let mut r{i} = ptr::read(base.add({i}));")
    for i, j in comps:
        ii, jj = (i, j) if i < j else (j, i)
        lines.append(f"    cswap_reg(&mut r{ii}, &mut r{jj});")
    for i in range(n):
        lines.append(f"    ptr::write(base.add({i}), r{i});")
    lines.append("}")
    return "\n".join(lines)


def emit_dispatch(ns: list[int]) -> str:
    lines: list[str] = []
    lines.append("")
    lines.append("/// Sort `v` using a register-based sorting network when `2 <= v.len() <= 32`.")
    lines.append("/// Falls back to `sort_unstable()` outside that range.")
    lines.append("#[inline(always)]")
    lines.append("pub fn sort_net_or_std(v: &mut [u64]) {")
    lines.append("    let n = v.len();")
    lines.append("    if n < 2 {")
    lines.append("        return;")
    lines.append("    }")
    lines.append("    if n > 32 {")
    lines.append("        v.sort_unstable();")
    lines.append("        return;")
    lines.append("    }")
    lines.append("    unsafe {")
    lines.append("        let base = v.as_mut_ptr();")
    lines.append("        match n {")
    for n in ns:
        lines.append(f"            {n} => sort{n}_net(base),")
    lines.append('            _ => unreachable!("missing network"),')
    lines.append("        }")
    lines.append("    }")
    lines.append("}")
    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--write",
        action="store_true",
        help="Write to src/bin_support/sort_nets_microbench_reg.rs",
    )
    parser.add_argument("--check", action="store_true", help="Exit non-zero if output is out of date")
    args = parser.parse_args()

    repo_root = Path(__file__).parent.parent
    out_path = repo_root / "src" / "bin_support" / "sort_nets_microbench_reg.rs"

    networks = load_networks(repo_root)
    ns = [n for n in range(2, 33) if n in networks]
    missing = [n for n in range(2, 33) if n not in networks]
    if missing:
        raise SystemExit(f"missing sorting networks for: {missing}")

    parts: list[str] = [emit_header()]
    for n in ns:
        parts.append(emit_sort_fn(n, networks[n]))
    parts.append(emit_dispatch(ns))
    rendered = "\n".join(parts) + "\n"

    if args.check:
        existing = out_path.read_text()
        if existing != rendered:
            raise SystemExit(
                "src/bin_support/sort_nets_microbench_reg.rs is out of date (run scripts/gen_sort_nets_microbench_reg.py --write)"
            )
        return

    if args.write:
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(rendered)
        return

    print(rendered)


if __name__ == "__main__":
    main()

